{"ast":null,"code":"var attributes = ['borderBottomWidth', 'borderLeftWidth', 'borderRightWidth', 'borderTopStyle', 'borderRightStyle', 'borderBottomStyle', 'borderLeftStyle', 'borderTopWidth', 'boxSizing', 'fontFamily', 'fontSize', 'fontWeight', 'height', 'letterSpacing', 'lineHeight', 'marginBottom', 'marginLeft', 'marginRight', 'marginTop', 'outlineWidth', 'overflow', 'overflowX', 'overflowY', 'paddingBottom', 'paddingLeft', 'paddingRight', 'paddingTop', 'textAlign', 'textOverflow', 'textTransform', 'whiteSpace', 'wordBreak', 'wordWrap'];\n/**\n * Create a mirror\n *\n * @param {Element} element The element\n * @param {string} html The html\n *\n * @return {object} The mirror object\n */\n\nvar createMirror = function createMirror(element, html) {\n  /**\n   * The mirror element\n   */\n  var mirror = document.createElement('div');\n  /**\n   * Create the CSS for the mirror object\n   *\n   * @return {object} The style object\n   */\n\n  var mirrorCss = function mirrorCss() {\n    var css = {\n      position: 'absolute',\n      left: -9999,\n      top: 0,\n      zIndex: -2000\n    };\n\n    if (element.tagName === 'TEXTAREA') {\n      attributes.push('width');\n    }\n\n    attributes.forEach(function (attr) {\n      css[attr] = getComputedStyle(element)[attr];\n    });\n    return css;\n  };\n  /**\n   * Initialize the mirror\n   *\n   * @param {string} html The html\n   *\n   * @return {void}\n   */\n\n\n  var initialize = function initialize(html) {\n    var styles = mirrorCss();\n    Object.keys(styles).forEach(function (key) {\n      mirror.style[key] = styles[key];\n    });\n    mirror.innerHTML = html;\n    element.parentNode.insertBefore(mirror, element.nextSibling);\n  };\n  /**\n   * Get the rect\n   *\n   * @return {Rect} The bounding rect\n   */\n\n\n  var rect = function rect() {\n    var marker = mirror.ownerDocument.getElementById('caret-position-marker');\n    var boundingRect = {\n      left: marker.offsetLeft,\n      top: marker.offsetTop,\n      height: marker.offsetHeight\n    };\n    mirror.parentNode.removeChild(mirror);\n    return boundingRect;\n  };\n\n  initialize(html);\n  return {\n    rect: rect\n  };\n};\n\nfunction _typeof(obj) {\n  \"@babel/helpers - typeof\";\n\n  if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n    _typeof = function (obj) {\n      return typeof obj;\n    };\n  } else {\n    _typeof = function (obj) {\n      return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n    };\n  }\n\n  return _typeof(obj);\n}\n/**\n * Check if a DOM Element is content editable\n *\n * @param {Element} element  The DOM element\n *\n * @return {bool} If it is content editable\n */\n\n\nvar isContentEditable = function isContentEditable(element) {\n  return !!(element.contentEditable ? element.contentEditable === 'true' : element.getAttribute('contenteditable') === 'true');\n};\n/**\n * Get the context from settings passed in\n *\n * @param {object} settings The settings object\n *\n * @return {object} window and document\n */\n\n\nvar getContext = function getContext() {\n  var settings = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  var customPos = settings.customPos,\n      iframe = settings.iframe,\n      noShadowCaret = settings.noShadowCaret;\n\n  if (iframe) {\n    return {\n      iframe: iframe,\n      window: iframe.contentWindow,\n      document: iframe.contentDocument || iframe.contentWindow.document,\n      noShadowCaret: noShadowCaret,\n      customPos: customPos\n    };\n  }\n\n  return {\n    window: window,\n    document: document,\n    noShadowCaret: noShadowCaret,\n    customPos: customPos\n  };\n};\n/**\n * Get the offset of an element\n *\n * @param {Element} element The DOM element\n * @param {object} ctx The context\n *\n * @return {object} top and left\n */\n\n\nvar getOffset = function getOffset(element, ctx) {\n  var win = ctx && ctx.window || window;\n  var doc = ctx && ctx.document || document;\n  var rect = element.getBoundingClientRect();\n  var docEl = doc.documentElement;\n  var scrollLeft = win.pageXOffset || docEl.scrollLeft;\n  var scrollTop = win.pageYOffset || docEl.scrollTop;\n  return {\n    top: rect.top + scrollTop,\n    left: rect.left + scrollLeft\n  };\n};\n/**\n * Check if a value is an object\n *\n * @param {any} value The value to check\n *\n * @return {bool} If it is an object\n */\n\n\nvar isObject = function isObject(value) {\n  return _typeof(value) === 'object' && value !== null;\n};\n/**\n * Create a Input caret object.\n *\n * @param {Element} element The element\n * @param {Object} ctx The context\n */\n\n\nvar createInputCaret = function createInputCaret(element, ctx) {\n  /**\n   * Get the current position\n   *\n   * @returns {int} The caret position\n   */\n  var getPos = function getPos() {\n    return element.selectionStart;\n  };\n  /**\n   * Set the position\n   *\n   * @param {int} pos The position\n   *\n   * @return {Element} The element\n   */\n\n\n  var setPos = function setPos(pos) {\n    element.setSelectionRange(pos, pos);\n    return element;\n  };\n  /**\n   * The offset\n   *\n   * @param {int} pos The position\n   *\n   * @return {object} The offset\n   */\n\n\n  var getOffset$1 = function getOffset$1(pos) {\n    var rect = getOffset(element);\n    var position = getPosition(pos);\n    return {\n      top: rect.top + position.top + ctx.document.body.scrollTop,\n      left: rect.left + position.left + ctx.document.body.scrollLeft,\n      height: position.height\n    };\n  };\n  /**\n   * Get the current position\n   *\n   * @param {int} pos The position\n   *\n   * @return {object} The position\n   */\n\n\n  var getPosition = function getPosition(pos) {\n    var format = function format(val) {\n      var value = val.replace(/<|>|`|\"|&/g, '?').replace(/\\r\\n|\\r|\\n/g, '<br/>');\n      return value;\n    };\n\n    if (ctx.customPos || ctx.customPos === 0) {\n      pos = ctx.customPos;\n    }\n\n    var position = pos === undefined ? getPos() : pos;\n    var startRange = element.value.slice(0, position);\n    var endRange = element.value.slice(position);\n    var html = \"<span style=\\\"position: relative; display: inline;\\\">\".concat(format(startRange), \"</span>\");\n    html += '<span id=\"caret-position-marker\" style=\"position: relative; display: inline;\">|</span>';\n    html += \"<span style=\\\"position: relative; display: inline;\\\">\".concat(format(endRange), \"</span>\");\n    var mirror = createMirror(element, html);\n    var rect = mirror.rect();\n    rect.pos = getPos();\n    return rect;\n  };\n\n  return {\n    getPos: getPos,\n    setPos: setPos,\n    getOffset: getOffset$1,\n    getPosition: getPosition\n  };\n};\n/**\n * Create an Editable Caret\n * @param {Element} element The editable element\n * @param {object|null} ctx The context\n *\n * @return {EditableCaret}\n */\n\n\nvar createEditableCaret = function createEditableCaret(element, ctx) {\n  /**\n   * Set the caret position\n   *\n   * @param {int} pos The position to se\n   *\n   * @return {Element} The element\n   */\n  var setPos = function setPos(pos) {\n    var sel = ctx.window.getSelection();\n\n    if (sel) {\n      var offset = 0;\n      var found = false;\n\n      var find = function find(position, parent) {\n        for (var i = 0; i < parent.childNodes.length; i++) {\n          var node = parent.childNodes[i];\n\n          if (found) {\n            break;\n          }\n\n          if (node.nodeType === 3) {\n            if (offset + node.length >= position) {\n              found = true;\n              var range = ctx.document.createRange();\n              range.setStart(node, position - offset);\n              sel.removeAllRanges();\n              sel.addRange(range);\n              break;\n            } else {\n              offset += node.length;\n            }\n          } else {\n            find(pos, node);\n          }\n        }\n      };\n\n      find(pos, element);\n    }\n\n    return element;\n  };\n  /**\n   * Get the offset\n   *\n   * @return {object} The offset\n   */\n\n\n  var getOffset = function getOffset() {\n    var range = getRange();\n    var offset = {\n      height: 0,\n      left: 0,\n      right: 0\n    };\n\n    if (!range) {\n      return offset;\n    }\n\n    var hasCustomPos = ctx.customPos || ctx.customPos === 0; // endContainer in Firefox would be the element at the start of\n    // the line\n\n    if (range.endOffset - 1 > 0 && range.endContainer !== element || hasCustomPos) {\n      var clonedRange = range.cloneRange();\n      var fixedPosition = hasCustomPos ? ctx.customPos : range.endOffset;\n      clonedRange.setStart(range.endContainer, fixedPosition - 1 < 0 ? 0 : fixedPosition - 1);\n      clonedRange.setEnd(range.endContainer, fixedPosition);\n      var rect = clonedRange.getBoundingClientRect();\n      offset = {\n        height: rect.height,\n        left: rect.left + rect.width,\n        top: rect.top\n      };\n      clonedRange.detach();\n    }\n\n    if ((!offset || offset && offset.height === 0) && !ctx.noShadowCaret) {\n      var _clonedRange = range.cloneRange();\n\n      var shadowCaret = ctx.document.createTextNode('|');\n\n      _clonedRange.insertNode(shadowCaret);\n\n      _clonedRange.selectNode(shadowCaret);\n\n      var _rect = _clonedRange.getBoundingClientRect();\n\n      offset = {\n        height: _rect.height,\n        left: _rect.left,\n        top: _rect.top\n      };\n      shadowCaret.parentNode.removeChild(shadowCaret);\n\n      _clonedRange.detach();\n    }\n\n    if (offset) {\n      var doc = ctx.document.documentElement;\n      offset.top += ctx.window.pageYOffset - (doc.clientTop || 0);\n      offset.left += ctx.window.pageXOffset - (doc.clientLeft || 0);\n    }\n\n    return offset;\n  };\n  /**\n   * Get the position\n   *\n   * @return {object} The position\n   */\n\n\n  var getPosition = function getPosition() {\n    var offset = getOffset();\n    var pos = getPos();\n    var rect = element.getBoundingClientRect();\n    var inputOffset = {\n      top: rect.top + ctx.document.body.scrollTop,\n      left: rect.left + ctx.document.body.scrollLeft\n    };\n    offset.left -= inputOffset.left;\n    offset.top -= inputOffset.top;\n    offset.pos = pos;\n    return offset;\n  };\n  /**\n   * Get the range\n   *\n   * @return {Range|null}\n   */\n\n\n  var getRange = function getRange() {\n    if (!ctx.window.getSelection) {\n      return;\n    }\n\n    var sel = ctx.window.getSelection();\n    return sel.rangeCount > 0 ? sel.getRangeAt(0) : null;\n  };\n  /**\n   * Get the caret position\n   *\n   * @return {int} The position\n   */\n\n\n  var getPos = function getPos() {\n    var range = getRange();\n    var clonedRange = range.cloneRange();\n    clonedRange.selectNodeContents(element);\n    clonedRange.setEnd(range.endContainer, range.endOffset);\n    var pos = clonedRange.toString().length;\n    clonedRange.detach();\n    return pos;\n  };\n\n  return {\n    getPos: getPos,\n    setPos: setPos,\n    getPosition: getPosition,\n    getOffset: getOffset,\n    getRange: getRange\n  };\n};\n\nvar createCaret = function createCaret(element, ctx) {\n  if (isContentEditable(element)) {\n    return createEditableCaret(element, ctx);\n  }\n\n  return createInputCaret(element, ctx);\n};\n\nvar position = function position(element, value) {\n  var settings = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  var options = settings;\n\n  if (isObject(value)) {\n    options = value;\n    value = null;\n  }\n\n  var ctx = getContext(options);\n  var caret = createCaret(element, ctx);\n\n  if (value || value === 0) {\n    return caret.setPos(value);\n  }\n\n  return caret.getPosition();\n};\n/**\n *\n * @param {Element} element The DOM element\n * @param {number|undefined} value The value to set\n * @param {object} settings Any settings for context\n */\n\n\nvar offset = function offset(element, value) {\n  var settings = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  var options = settings;\n\n  if (isObject(value)) {\n    options = value;\n    value = null;\n  }\n\n  var ctx = getContext(options);\n  var caret = createCaret(element, ctx);\n  return caret.getOffset(value);\n};\n\nexport { getOffset, offset, position };","map":{"version":3,"sources":["../../src/mirror.js","../../src/utils.js","../../src/input.js","../../src/editable.js","../../src/main.js"],"names":["attributes","createMirror","mirror","document","mirrorCss","css","position","left","top","zIndex","element","getComputedStyle","initialize","styles","Object","rect","marker","boundingRect","height","offsetHeight","isContentEditable","getContext","settings","customPos","iframe","noShadowCaret","window","getOffset","win","ctx","doc","docEl","scrollLeft","scrollTop","isObject","value","createInputCaret","getPos","setPos","elementOffset","getPosition","format","val","pos","startRange","endRange","html","createEditableCaret","sel","offset","found","find","i","parent","node","range","getRange","right","hasCustomPos","clonedRange","fixedPosition","shadowCaret","inputOffset","createCaret","options","caret"],"mappings":"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","sourcesContent":["const attributes = [\n  'borderBottomWidth',\n  'borderLeftWidth',\n  'borderRightWidth',\n  'borderTopStyle',\n  'borderRightStyle',\n  'borderBottomStyle',\n  'borderLeftStyle',\n  'borderTopWidth',\n  'boxSizing',\n  'fontFamily',\n  'fontSize',\n  'fontWeight',\n  'height',\n  'letterSpacing',\n  'lineHeight',\n  'marginBottom',\n  'marginLeft',\n  'marginRight',\n  'marginTop',\n  'outlineWidth',\n  'overflow',\n  'overflowX',\n  'overflowY',\n  'paddingBottom',\n  'paddingLeft',\n  'paddingRight',\n  'paddingTop',\n  'textAlign',\n  'textOverflow',\n  'textTransform',\n  'whiteSpace',\n  'wordBreak',\n  'wordWrap',\n];\n\n/**\n * Create a mirror\n *\n * @param {Element} element The element\n * @param {string} html The html\n *\n * @return {object} The mirror object\n */\nconst createMirror = (element, html) => {\n\n  /**\n   * The mirror element\n   */\n  const mirror = document.createElement('div');\n\n  /**\n   * Create the CSS for the mirror object\n   *\n   * @return {object} The style object\n   */\n  const mirrorCss = () => {\n    const css = {\n      position: 'absolute',\n      left: -9999,\n      top: 0,\n      zIndex: -2000\n    };\n\n    if (element.tagName === 'TEXTAREA') {\n      attributes.push('width');\n    }\n\n    attributes.forEach((attr) => {\n      css[attr] = getComputedStyle(element)[attr];\n    });\n\n    return css;\n  };\n\n  /**\n   * Initialize the mirror\n   *\n   * @param {string} html The html\n   *\n   * @return {void}\n   */\n  const initialize = (html) => {\n    const styles = mirrorCss();\n    Object.keys(styles).forEach(key => {\n      mirror.style[key] = styles[key];\n    });\n    mirror.innerHTML = html;\n    element.parentNode.insertBefore(mirror, element.nextSibling);\n  };\n\n  /**\n   * Get the rect\n   *\n   * @return {Rect} The bounding rect\n   */\n  const rect = () => {\n    const marker = mirror.ownerDocument.getElementById('caret-position-marker');\n    const boundingRect = {\n      left: marker.offsetLeft,\n      top: marker.offsetTop,\n      height: marker.offsetHeight\n    };\n    mirror.parentNode.removeChild(mirror);\n\n    return boundingRect;\n  };\n\n  initialize(html);\n\n  return {\n    rect,\n  };\n};\n\nexport default createMirror;\n","/**\n * Check if a DOM Element is content editable\n *\n * @param {Element} element  The DOM element\n *\n * @return {bool} If it is content editable\n */\nexport const isContentEditable = (element) => !!(\n  element.contentEditable ?\n    element.contentEditable === 'true' :\n    element.getAttribute('contenteditable') === 'true'\n);\n\n/**\n * Get the context from settings passed in\n *\n * @param {object} settings The settings object\n *\n * @return {object} window and document\n */\nexport const getContext = (settings = {}) => {\n  const { customPos, iframe, noShadowCaret } = settings;\n  if (iframe) {\n    return {\n      iframe,\n      window: iframe.contentWindow,\n      document: iframe.contentDocument || iframe.contentWindow.document,\n      noShadowCaret,\n      customPos,\n    };\n  }\n\n  return {\n    window,\n    document,\n    noShadowCaret,\n    customPos,\n  };\n};\n\n/**\n * Get the offset of an element\n *\n * @param {Element} element The DOM element\n * @param {object} ctx The context\n *\n * @return {object} top and left\n */\nexport const getOffset = (element, ctx) => {\n  const win = ctx && ctx.window || window;\n  const doc = ctx && ctx.document || document;\n  const rect = element.getBoundingClientRect();\n  const docEl = doc.documentElement;\n  const scrollLeft = win.pageXOffset || docEl.scrollLeft;\n  const scrollTop = win.pageYOffset || docEl.scrollTop;\n\n  return {\n    top: rect.top + scrollTop,\n    left: rect.left + scrollLeft\n  };\n};\n\n/**\n * Check if a value is an object\n *\n * @param {any} value The value to check\n *\n * @return {bool} If it is an object\n */\nexport const isObject = (value) => typeof value === 'object' && value !== null;\n","import createMirror from './mirror';\nimport { getOffset as elementOffset } from './utils';\n\n/**\n * Create a Input caret object.\n *\n * @param {Element} element The element\n * @param {Object} ctx The context\n */\nconst createInputCaret = (element, ctx) => {\n\n  /**\n   * Get the current position\n   *\n   * @returns {int} The caret position\n   */\n  const getPos = () => {\n    return element.selectionStart;\n  };\n\n  /**\n   * Set the position\n   *\n   * @param {int} pos The position\n   *\n   * @return {Element} The element\n   */\n  const setPos = (pos) => {\n    element.setSelectionRange(pos, pos);\n\n    return element;\n  };\n\n  /**\n   * The offset\n   *\n   * @param {int} pos The position\n   *\n   * @return {object} The offset\n   */\n  const getOffset = (pos) => {\n    const rect = elementOffset(element);\n    const position = getPosition(pos);\n\n    return {\n      top: rect.top + position.top + ctx.document.body.scrollTop,\n      left: rect.left + position.left + ctx.document.body.scrollLeft,\n      height: position.height,\n    };\n  };\n\n  /**\n   * Get the current position\n   *\n   * @param {int} pos The position\n   *\n   * @return {object} The position\n   */\n  const getPosition = (pos) => {\n    const format = (val) => {\n      let value = val.replace(/<|>|`|\"|&/g, '?')\n        .replace(/\\r\\n|\\r|\\n/g,'<br/>');\n      return value;\n    };\n\n    if (ctx.customPos || ctx.customPos === 0) {\n      pos = ctx.customPos;\n    }\n\n    const position = pos === undefined ? getPos() : pos;\n    const startRange = element.value.slice(0, position);\n    const endRange = element.value.slice(position);\n    let html = `<span style=\"position: relative; display: inline;\">${format(startRange)}</span>`;\n    html += '<span id=\"caret-position-marker\" style=\"position: relative; display: inline;\">|</span>';\n    html += `<span style=\"position: relative; display: inline;\">${format(endRange)}</span>`;\n\n    const mirror = createMirror(element, html);\n    const rect = mirror.rect();\n    rect.pos = getPos();\n\n    return rect;\n  };\n\n  return {\n    getPos,\n    setPos,\n    getOffset,\n    getPosition,\n  };\n};\n\nexport default createInputCaret;\n","/**\n * Create an Editable Caret\n * @param {Element} element The editable element\n * @param {object|null} ctx The context\n *\n * @return {EditableCaret}\n */\nconst createEditableCaret = (element, ctx) => {\n\n  /**\n   * Set the caret position\n   *\n   * @param {int} pos The position to se\n   *\n   * @return {Element} The element\n   */\n  const setPos = (pos) => {\n    const sel = ctx.window.getSelection();\n    if (sel) {\n      let offset = 0;\n      let found = false;\n      const find = (position, parent) => {\n        for (let i = 0; i < parent.childNodes.length; i++) {\n          const node = parent.childNodes[i];\n          if (found) {\n            break;\n          }\n          if (node.nodeType === 3) {\n            if (offset + node.length >= position) {\n              found = true;\n              const range = ctx.document.createRange();\n              range.setStart(node, position - offset);\n              sel.removeAllRanges();\n              sel.addRange(range);\n              break;\n            } else {\n              offset += node.length;\n            }\n          } else {\n            find(pos, node);\n          }\n        }\n      };\n      find(pos, element);\n    }\n\n    return element;\n  };\n\n  /**\n   * Get the offset\n   *\n   * @return {object} The offset\n   */\n  const getOffset = () => {\n    const range = getRange();\n    let offset = {\n      height: 0,\n      left: 0,\n      right: 0,\n    };\n\n    if (!range) {\n      return offset;\n    }\n\n    const hasCustomPos = ctx.customPos || ctx.customPos === 0;\n\n    // endContainer in Firefox would be the element at the start of\n    // the line\n    if ((range.endOffset - 1 > 0 && range.endContainer !== element) || hasCustomPos) {\n      const clonedRange = range.cloneRange();\n      const fixedPosition = hasCustomPos ? ctx.customPos : range.endOffset;\n      clonedRange.setStart(range.endContainer, fixedPosition - 1 < 0 ? 0 : fixedPosition - 1);\n      clonedRange.setEnd(range.endContainer, fixedPosition);\n      const rect = clonedRange.getBoundingClientRect();\n      offset = {\n        height: rect.height,\n        left: rect.left + rect.width,\n        top: rect.top,\n      };\n      clonedRange.detach();\n    }\n\n    if ((!offset || (offset && offset.height === 0)) && !ctx.noShadowCaret) {\n      const clonedRange = range.cloneRange();\n      const shadowCaret = ctx.document.createTextNode('|');\n      clonedRange.insertNode(shadowCaret);\n      clonedRange.selectNode(shadowCaret);\n      const rect = clonedRange.getBoundingClientRect();\n      offset = {\n        height: rect.height,\n        left: rect.left,\n        top: rect.top,\n      };\n      shadowCaret.parentNode.removeChild(shadowCaret);\n      clonedRange.detach();\n    }\n\n    if (offset) {\n      const doc = ctx.document.documentElement;\n      offset.top += ctx.window.pageYOffset - (doc.clientTop || 0);\n      offset.left += ctx.window.pageXOffset - (doc.clientLeft || 0);\n    }\n\n    return offset;\n  };\n\n  /**\n   * Get the position\n   *\n   * @return {object} The position\n   */\n  const getPosition = () => {\n    const offset = getOffset();\n    const pos = getPos();\n    const rect = element.getBoundingClientRect();\n    const inputOffset = {\n      top: rect.top + ctx.document.body.scrollTop,\n      left: rect.left + ctx.document.body.scrollLeft\n    };\n    offset.left -= inputOffset.left;\n    offset.top -= inputOffset.top;\n    offset.pos = pos;\n\n    return offset;\n  };\n\n  /**\n   * Get the range\n   *\n   * @return {Range|null}\n   */\n  const getRange = () => {\n    if (!ctx.window.getSelection) {\n      return;\n    }\n    const sel = ctx.window.getSelection();\n\n    return sel.rangeCount > 0 ? sel.getRangeAt(0) : null;\n  };\n\n  /**\n   * Get the caret position\n   *\n   * @return {int} The position\n   */\n  const getPos = () => {\n    const range = getRange();\n    const clonedRange = range.cloneRange();\n    clonedRange.selectNodeContents(element);\n    clonedRange.setEnd(range.endContainer, range.endOffset);\n    const pos = clonedRange.toString().length;\n    clonedRange.detach();\n\n    return pos;\n  };\n\n  return {\n    getPos,\n    setPos,\n    getPosition,\n    getOffset,\n    getRange,\n  };\n};\n\nexport default createEditableCaret;\n","import createInputCaret from './input';\nimport createEditableCaret from './editable';\nimport {\n  isContentEditable,\n  getContext,\n  isObject,\n} from './utils';\n\nexport { getOffset } from './utils';\n\nconst createCaret = (element, ctx) => {\n  if (isContentEditable(element)) {\n    return createEditableCaret(element, ctx);\n  }\n\n  return createInputCaret(element, ctx);\n};\n\nexport const position = (element, value, settings = {}) => {\n  let options = settings;\n  if (isObject(value)) {\n    options = value;\n    value = null;\n  }\n  const ctx = getContext(options);\n  const caret = createCaret(element, ctx);\n\n  if (value || value === 0) {\n    return caret.setPos(value);\n  }\n\n  return caret.getPosition();\n};\n\n/**\n *\n * @param {Element} element The DOM element\n * @param {number|undefined} value The value to set\n * @param {object} settings Any settings for context\n */\nexport const offset = (element, value, settings = {}) => {\n  let options = settings;\n  if (isObject(value)) {\n    options = value;\n    value = null;\n  }\n\n  const ctx = getContext(options);\n  const caret = createCaret(element, ctx);\n  return caret.getOffset(value);\n};\n"]},"metadata":{},"sourceType":"module"}