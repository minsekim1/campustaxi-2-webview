{"version":3,"sources":["../../src/mirror.js","../../src/utils.js","../../src/input.js","../../src/editable.js","../../src/main.js"],"names":["createMirror","element","html","css","styles","mirror","document","createElement","position","left","top","zIndex","tagName","attributes","push","forEach","attr","getComputedStyle","Object","keys","key","style","innerHTML","parentNode","insertBefore","nextSibling","rect","marker","ownerDocument","getElementById","boundingRect","offsetLeft","offsetTop","height","offsetHeight","removeChild","getContext","settings","arguments","length","undefined","customPos","iframe","noShadowCaret","window","contentWindow","contentDocument","getOffset","ctx","win","doc","getBoundingClientRect","docEl","documentElement","scrollLeft","pageXOffset","scrollTop","pageYOffset","isObject","value","_typeof","createInputCaret","getPos","selectionStart","getPosition","pos","format","val","replace","startRange","slice","endRange","concat","setPos","setSelectionRange","elementOffset","body","createEditableCaret","range","getRange","offset","right","hasCustomPos","endOffset","endContainer","clonedRange","cloneRange","fixedPosition","setStart","setEnd","width","detach","shadowCaret","createTextNode","insertNode","selectNode","clientTop","clientLeft","getSelection","sel","rangeCount","getRangeAt","selectNodeContents","toString","found","find","parent","i","childNodes","node","nodeType","createRange","removeAllRanges","addRange","inputOffset","createCaret","contentEditable","getAttribute","options","caret"],"mappings":"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","file":"main.min.js","sourcesContent":["const attributes = [\n  'borderBottomWidth',\n  'borderLeftWidth',\n  'borderRightWidth',\n  'borderTopStyle',\n  'borderRightStyle',\n  'borderBottomStyle',\n  'borderLeftStyle',\n  'borderTopWidth',\n  'boxSizing',\n  'fontFamily',\n  'fontSize',\n  'fontWeight',\n  'height',\n  'letterSpacing',\n  'lineHeight',\n  'marginBottom',\n  'marginLeft',\n  'marginRight',\n  'marginTop',\n  'outlineWidth',\n  'overflow',\n  'overflowX',\n  'overflowY',\n  'paddingBottom',\n  'paddingLeft',\n  'paddingRight',\n  'paddingTop',\n  'textAlign',\n  'textOverflow',\n  'textTransform',\n  'whiteSpace',\n  'wordBreak',\n  'wordWrap',\n];\n\n/**\n * Create a mirror\n *\n * @param {Element} element The element\n * @param {string} html The html\n *\n * @return {object} The mirror object\n */\nconst createMirror = (element, html) => {\n\n  /**\n   * The mirror element\n   */\n  const mirror = document.createElement('div');\n\n  /**\n   * Create the CSS for the mirror object\n   *\n   * @return {object} The style object\n   */\n  const mirrorCss = () => {\n    const css = {\n      position: 'absolute',\n      left: -9999,\n      top: 0,\n      zIndex: -2000\n    };\n\n    if (element.tagName === 'TEXTAREA') {\n      attributes.push('width');\n    }\n\n    attributes.forEach((attr) => {\n      css[attr] = getComputedStyle(element)[attr];\n    });\n\n    return css;\n  };\n\n  /**\n   * Initialize the mirror\n   *\n   * @param {string} html The html\n   *\n   * @return {void}\n   */\n  const initialize = (html) => {\n    const styles = mirrorCss();\n    Object.keys(styles).forEach(key => {\n      mirror.style[key] = styles[key];\n    });\n    mirror.innerHTML = html;\n    element.parentNode.insertBefore(mirror, element.nextSibling);\n  };\n\n  /**\n   * Get the rect\n   *\n   * @return {Rect} The bounding rect\n   */\n  const rect = () => {\n    const marker = mirror.ownerDocument.getElementById('caret-position-marker');\n    const boundingRect = {\n      left: marker.offsetLeft,\n      top: marker.offsetTop,\n      height: marker.offsetHeight\n    };\n    mirror.parentNode.removeChild(mirror);\n\n    return boundingRect;\n  };\n\n  initialize(html);\n\n  return {\n    rect,\n  };\n};\n\nexport default createMirror;\n","/**\n * Check if a DOM Element is content editable\n *\n * @param {Element} element  The DOM element\n *\n * @return {bool} If it is content editable\n */\nexport const isContentEditable = (element) => !!(\n  element.contentEditable ?\n    element.contentEditable === 'true' :\n    element.getAttribute('contenteditable') === 'true'\n);\n\n/**\n * Get the context from settings passed in\n *\n * @param {object} settings The settings object\n *\n * @return {object} window and document\n */\nexport const getContext = (settings = {}) => {\n  const { customPos, iframe, noShadowCaret } = settings;\n  if (iframe) {\n    return {\n      iframe,\n      window: iframe.contentWindow,\n      document: iframe.contentDocument || iframe.contentWindow.document,\n      noShadowCaret,\n      customPos,\n    };\n  }\n\n  return {\n    window,\n    document,\n    noShadowCaret,\n    customPos,\n  };\n};\n\n/**\n * Get the offset of an element\n *\n * @param {Element} element The DOM element\n * @param {object} ctx The context\n *\n * @return {object} top and left\n */\nexport const getOffset = (element, ctx) => {\n  const win = ctx && ctx.window || window;\n  const doc = ctx && ctx.document || document;\n  const rect = element.getBoundingClientRect();\n  const docEl = doc.documentElement;\n  const scrollLeft = win.pageXOffset || docEl.scrollLeft;\n  const scrollTop = win.pageYOffset || docEl.scrollTop;\n\n  return {\n    top: rect.top + scrollTop,\n    left: rect.left + scrollLeft\n  };\n};\n\n/**\n * Check if a value is an object\n *\n * @param {any} value The value to check\n *\n * @return {bool} If it is an object\n */\nexport const isObject = (value) => typeof value === 'object' && value !== null;\n","import createMirror from './mirror';\nimport { getOffset as elementOffset } from './utils';\n\n/**\n * Create a Input caret object.\n *\n * @param {Element} element The element\n * @param {Object} ctx The context\n */\nconst createInputCaret = (element, ctx) => {\n\n  /**\n   * Get the current position\n   *\n   * @returns {int} The caret position\n   */\n  const getPos = () => {\n    return element.selectionStart;\n  };\n\n  /**\n   * Set the position\n   *\n   * @param {int} pos The position\n   *\n   * @return {Element} The element\n   */\n  const setPos = (pos) => {\n    element.setSelectionRange(pos, pos);\n\n    return element;\n  };\n\n  /**\n   * The offset\n   *\n   * @param {int} pos The position\n   *\n   * @return {object} The offset\n   */\n  const getOffset = (pos) => {\n    const rect = elementOffset(element);\n    const position = getPosition(pos);\n\n    return {\n      top: rect.top + position.top + ctx.document.body.scrollTop,\n      left: rect.left + position.left + ctx.document.body.scrollLeft,\n      height: position.height,\n    };\n  };\n\n  /**\n   * Get the current position\n   *\n   * @param {int} pos The position\n   *\n   * @return {object} The position\n   */\n  const getPosition = (pos) => {\n    const format = (val) => {\n      let value = val.replace(/<|>|`|\"|&/g, '?')\n        .replace(/\\r\\n|\\r|\\n/g,'<br/>');\n      return value;\n    };\n\n    if (ctx.customPos || ctx.customPos === 0) {\n      pos = ctx.customPos;\n    }\n\n    const position = pos === undefined ? getPos() : pos;\n    const startRange = element.value.slice(0, position);\n    const endRange = element.value.slice(position);\n    let html = `<span style=\"position: relative; display: inline;\">${format(startRange)}</span>`;\n    html += '<span id=\"caret-position-marker\" style=\"position: relative; display: inline;\">|</span>';\n    html += `<span style=\"position: relative; display: inline;\">${format(endRange)}</span>`;\n\n    const mirror = createMirror(element, html);\n    const rect = mirror.rect();\n    rect.pos = getPos();\n\n    return rect;\n  };\n\n  return {\n    getPos,\n    setPos,\n    getOffset,\n    getPosition,\n  };\n};\n\nexport default createInputCaret;\n","/**\n * Create an Editable Caret\n * @param {Element} element The editable element\n * @param {object|null} ctx The context\n *\n * @return {EditableCaret}\n */\nconst createEditableCaret = (element, ctx) => {\n\n  /**\n   * Set the caret position\n   *\n   * @param {int} pos The position to se\n   *\n   * @return {Element} The element\n   */\n  const setPos = (pos) => {\n    const sel = ctx.window.getSelection();\n    if (sel) {\n      let offset = 0;\n      let found = false;\n      const find = (position, parent) => {\n        for (let i = 0; i < parent.childNodes.length; i++) {\n          const node = parent.childNodes[i];\n          if (found) {\n            break;\n          }\n          if (node.nodeType === 3) {\n            if (offset + node.length >= position) {\n              found = true;\n              const range = ctx.document.createRange();\n              range.setStart(node, position - offset);\n              sel.removeAllRanges();\n              sel.addRange(range);\n              break;\n            } else {\n              offset += node.length;\n            }\n          } else {\n            find(pos, node);\n          }\n        }\n      };\n      find(pos, element);\n    }\n\n    return element;\n  };\n\n  /**\n   * Get the offset\n   *\n   * @return {object} The offset\n   */\n  const getOffset = () => {\n    const range = getRange();\n    let offset = {\n      height: 0,\n      left: 0,\n      right: 0,\n    };\n\n    if (!range) {\n      return offset;\n    }\n\n    const hasCustomPos = ctx.customPos || ctx.customPos === 0;\n\n    // endContainer in Firefox would be the element at the start of\n    // the line\n    if ((range.endOffset - 1 > 0 && range.endContainer !== element) || hasCustomPos) {\n      const clonedRange = range.cloneRange();\n      const fixedPosition = hasCustomPos ? ctx.customPos : range.endOffset;\n      clonedRange.setStart(range.endContainer, fixedPosition - 1 < 0 ? 0 : fixedPosition - 1);\n      clonedRange.setEnd(range.endContainer, fixedPosition);\n      const rect = clonedRange.getBoundingClientRect();\n      offset = {\n        height: rect.height,\n        left: rect.left + rect.width,\n        top: rect.top,\n      };\n      clonedRange.detach();\n    }\n\n    if ((!offset || (offset && offset.height === 0)) && !ctx.noShadowCaret) {\n      const clonedRange = range.cloneRange();\n      const shadowCaret = ctx.document.createTextNode('|');\n      clonedRange.insertNode(shadowCaret);\n      clonedRange.selectNode(shadowCaret);\n      const rect = clonedRange.getBoundingClientRect();\n      offset = {\n        height: rect.height,\n        left: rect.left,\n        top: rect.top,\n      };\n      shadowCaret.parentNode.removeChild(shadowCaret);\n      clonedRange.detach();\n    }\n\n    if (offset) {\n      const doc = ctx.document.documentElement;\n      offset.top += ctx.window.pageYOffset - (doc.clientTop || 0);\n      offset.left += ctx.window.pageXOffset - (doc.clientLeft || 0);\n    }\n\n    return offset;\n  };\n\n  /**\n   * Get the position\n   *\n   * @return {object} The position\n   */\n  const getPosition = () => {\n    const offset = getOffset();\n    const pos = getPos();\n    const rect = element.getBoundingClientRect();\n    const inputOffset = {\n      top: rect.top + ctx.document.body.scrollTop,\n      left: rect.left + ctx.document.body.scrollLeft\n    };\n    offset.left -= inputOffset.left;\n    offset.top -= inputOffset.top;\n    offset.pos = pos;\n\n    return offset;\n  };\n\n  /**\n   * Get the range\n   *\n   * @return {Range|null}\n   */\n  const getRange = () => {\n    if (!ctx.window.getSelection) {\n      return;\n    }\n    const sel = ctx.window.getSelection();\n\n    return sel.rangeCount > 0 ? sel.getRangeAt(0) : null;\n  };\n\n  /**\n   * Get the caret position\n   *\n   * @return {int} The position\n   */\n  const getPos = () => {\n    const range = getRange();\n    const clonedRange = range.cloneRange();\n    clonedRange.selectNodeContents(element);\n    clonedRange.setEnd(range.endContainer, range.endOffset);\n    const pos = clonedRange.toString().length;\n    clonedRange.detach();\n\n    return pos;\n  };\n\n  return {\n    getPos,\n    setPos,\n    getPosition,\n    getOffset,\n    getRange,\n  };\n};\n\nexport default createEditableCaret;\n","import createInputCaret from './input';\nimport createEditableCaret from './editable';\nimport {\n  isContentEditable,\n  getContext,\n  isObject,\n} from './utils';\n\nexport { getOffset } from './utils';\n\nconst createCaret = (element, ctx) => {\n  if (isContentEditable(element)) {\n    return createEditableCaret(element, ctx);\n  }\n\n  return createInputCaret(element, ctx);\n};\n\nexport const position = (element, value, settings = {}) => {\n  let options = settings;\n  if (isObject(value)) {\n    options = value;\n    value = null;\n  }\n  const ctx = getContext(options);\n  const caret = createCaret(element, ctx);\n\n  if (value || value === 0) {\n    return caret.setPos(value);\n  }\n\n  return caret.getPosition();\n};\n\n/**\n *\n * @param {Element} element The DOM element\n * @param {number|undefined} value The value to set\n * @param {object} settings Any settings for context\n */\nexport const offset = (element, value, settings = {}) => {\n  let options = settings;\n  if (isObject(value)) {\n    options = value;\n    value = null;\n  }\n\n  const ctx = getContext(options);\n  const caret = createCaret(element, ctx);\n  return caret.getOffset(value);\n};\n"]}